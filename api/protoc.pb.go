// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/protoc.proto

package api

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type GoPluginType int32

const (
	GoPluginType_GO_PLUGIN_TYPE_NONE   GoPluginType = 0
	GoPluginType_GO_PLUGIN_TYPE_GO     GoPluginType = 1
	GoPluginType_GO_PLUGIN_TYPE_GOFAST GoPluginType = 2
)

var GoPluginType_name = map[int32]string{
	0: "GO_PLUGIN_TYPE_NONE",
	1: "GO_PLUGIN_TYPE_GO",
	2: "GO_PLUGIN_TYPE_GOFAST",
}
var GoPluginType_value = map[string]int32{
	"GO_PLUGIN_TYPE_NONE":   0,
	"GO_PLUGIN_TYPE_GO":     1,
	"GO_PLUGIN_TYPE_GOFAST": 2,
}

func (x GoPluginType) String() string {
	return proto.EnumName(GoPluginType_name, int32(x))
}
func (GoPluginType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_protoc_6cb717615ecba7f8, []int{0}
}

type GogoPluginType int32

const (
	GogoPluginType_GOGO_PLUGIN_TYPE_NONE       GogoPluginType = 0
	GogoPluginType_GOGO_PLUGIN_TYPE_GOGO       GogoPluginType = 1
	GogoPluginType_GOGO_PLUGIN_TYPE_GOGOFAST   GogoPluginType = 2
	GogoPluginType_GOGO_PLUGIN_TYPE_GOGOFASTER GogoPluginType = 3
	GogoPluginType_GOGO_PLUGIN_TYPE_GOGOSLICK  GogoPluginType = 4
)

var GogoPluginType_name = map[int32]string{
	0: "GOGO_PLUGIN_TYPE_NONE",
	1: "GOGO_PLUGIN_TYPE_GOGO",
	2: "GOGO_PLUGIN_TYPE_GOGOFAST",
	3: "GOGO_PLUGIN_TYPE_GOGOFASTER",
	4: "GOGO_PLUGIN_TYPE_GOGOSLICK",
}
var GogoPluginType_value = map[string]int32{
	"GOGO_PLUGIN_TYPE_NONE":       0,
	"GOGO_PLUGIN_TYPE_GOGO":       1,
	"GOGO_PLUGIN_TYPE_GOGOFAST":   2,
	"GOGO_PLUGIN_TYPE_GOGOFASTER": 3,
	"GOGO_PLUGIN_TYPE_GOGOSLICK":  4,
}

func (x GogoPluginType) String() string {
	return proto.EnumName(GogoPluginType_name, int32(x))
}
func (GogoPluginType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_protoc_6cb717615ecba7f8, []int{1}
}

type CompileOptions struct {
	Grpc                        bool              `protobuf:"varint,1,opt,name=grpc,proto3" json:"grpc,omitempty"`
	GrpcGateway                 bool              `protobuf:"varint,2,opt,name=grpc_gateway,json=grpcGateway,proto3" json:"grpc_gateway,omitempty"`
	NoDefaultIncludes           bool              `protobuf:"varint,3,opt,name=no_default_includes,json=noDefaultIncludes,proto3" json:"no_default_includes,omitempty"`
	ExcludePattern              []string          `protobuf:"bytes,4,rep,name=exclude_pattern,json=excludePattern,proto3" json:"exclude_pattern,omitempty"`
	RelContext                  string            `protobuf:"bytes,5,opt,name=rel_context,json=relContext,proto3" json:"rel_context,omitempty"`
	ExtraPluginFlag             []string          `protobuf:"bytes,6,rep,name=extra_plugin_flag,json=extraPluginFlag,proto3" json:"extra_plugin_flag,omitempty"`
	Cpp                         bool              `protobuf:"varint,20,opt,name=cpp,proto3" json:"cpp,omitempty"`
	CppRelOut                   string            `protobuf:"bytes,21,opt,name=cpp_rel_out,json=cppRelOut,proto3" json:"cpp_rel_out,omitempty"`
	Csharp                      bool              `protobuf:"varint,30,opt,name=csharp,proto3" json:"csharp,omitempty"`
	CsharpRelOut                string            `protobuf:"bytes,31,opt,name=csharp_rel_out,json=csharpRelOut,proto3" json:"csharp_rel_out,omitempty"`
	Go                          bool              `protobuf:"varint,40,opt,name=go,proto3" json:"go,omitempty"`
	GoPluginType                GoPluginType      `protobuf:"varint,41,opt,name=go_plugin_type,json=goPluginType,proto3,enum=api.GoPluginType" json:"go_plugin_type,omitempty"`
	GoRelOut                    string            `protobuf:"bytes,42,opt,name=go_rel_out,json=goRelOut,proto3" json:"go_rel_out,omitempty"`
	GoImportPath                string            `protobuf:"bytes,43,opt,name=go_import_path,json=goImportPath,proto3" json:"go_import_path,omitempty"`
	GoNoDefaultModifiers        bool              `protobuf:"varint,44,opt,name=go_no_default_modifiers,json=goNoDefaultModifiers,proto3" json:"go_no_default_modifiers,omitempty"`
	GoModifiers                 map[string]string `protobuf:"bytes,45,rep,name=go_modifiers,json=goModifiers,proto3" json:"go_modifiers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Gogo                        bool              `protobuf:"varint,50,opt,name=gogo,proto3" json:"gogo,omitempty"`
	GogoPluginType              GogoPluginType    `protobuf:"varint,51,opt,name=gogo_plugin_type,json=gogoPluginType,proto3,enum=api.GogoPluginType" json:"gogo_plugin_type,omitempty"`
	GogoRelOut                  string            `protobuf:"bytes,52,opt,name=gogo_rel_out,json=gogoRelOut,proto3" json:"gogo_rel_out,omitempty"`
	GogoImportPath              string            `protobuf:"bytes,53,opt,name=gogo_import_path,json=gogoImportPath,proto3" json:"gogo_import_path,omitempty"`
	GogoNoDefaultModifiers      bool              `protobuf:"varint,54,opt,name=gogo_no_default_modifiers,json=gogoNoDefaultModifiers,proto3" json:"gogo_no_default_modifiers,omitempty"`
	GogoModifiers               map[string]string `protobuf:"bytes,55,rep,name=gogo_modifiers,json=gogoModifiers,proto3" json:"gogo_modifiers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Objc                        bool              `protobuf:"varint,60,opt,name=objc,proto3" json:"objc,omitempty"`
	ObjcRelOut                  string            `protobuf:"bytes,61,opt,name=objc_rel_out,json=objcRelOut,proto3" json:"objc_rel_out,omitempty"`
	Python                      bool              `protobuf:"varint,70,opt,name=python,proto3" json:"python,omitempty"`
	PythonRelOut                string            `protobuf:"bytes,71,opt,name=python_rel_out,json=pythonRelOut,proto3" json:"python_rel_out,omitempty"`
	Ruby                        bool              `protobuf:"varint,80,opt,name=ruby,proto3" json:"ruby,omitempty"`
	RubyRelOut                  string            `protobuf:"bytes,81,opt,name=ruby_rel_out,json=rubyRelOut,proto3" json:"ruby_rel_out,omitempty"`
	DescriptorSet               bool              `protobuf:"varint,90,opt,name=descriptor_set,json=descriptorSet,proto3" json:"descriptor_set,omitempty"`
	DescriptorSetRelOut         string            `protobuf:"bytes,91,opt,name=descriptor_set_rel_out,json=descriptorSetRelOut,proto3" json:"descriptor_set_rel_out,omitempty"`
	DescriptorSetFileName       string            `protobuf:"bytes,92,opt,name=descriptor_set_file_name,json=descriptorSetFileName,proto3" json:"descriptor_set_file_name,omitempty"`
	DescriptorSetIncludeImports bool              `protobuf:"varint,93,opt,name=descriptor_set_include_imports,json=descriptorSetIncludeImports,proto3" json:"descriptor_set_include_imports,omitempty"`
}

func (m *CompileOptions) Reset()         { *m = CompileOptions{} }
func (m *CompileOptions) String() string { return proto.CompactTextString(m) }
func (*CompileOptions) ProtoMessage()    {}
func (*CompileOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_protoc_6cb717615ecba7f8, []int{0}
}
func (m *CompileOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompileOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompileOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CompileOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompileOptions.Merge(dst, src)
}
func (m *CompileOptions) XXX_Size() int {
	return m.Size()
}
func (m *CompileOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_CompileOptions.DiscardUnknown(m)
}

var xxx_messageInfo_CompileOptions proto.InternalMessageInfo

func (m *CompileOptions) GetGrpc() bool {
	if m != nil {
		return m.Grpc
	}
	return false
}

func (m *CompileOptions) GetGrpcGateway() bool {
	if m != nil {
		return m.GrpcGateway
	}
	return false
}

func (m *CompileOptions) GetNoDefaultIncludes() bool {
	if m != nil {
		return m.NoDefaultIncludes
	}
	return false
}

func (m *CompileOptions) GetExcludePattern() []string {
	if m != nil {
		return m.ExcludePattern
	}
	return nil
}

func (m *CompileOptions) GetRelContext() string {
	if m != nil {
		return m.RelContext
	}
	return ""
}

func (m *CompileOptions) GetExtraPluginFlag() []string {
	if m != nil {
		return m.ExtraPluginFlag
	}
	return nil
}

func (m *CompileOptions) GetCpp() bool {
	if m != nil {
		return m.Cpp
	}
	return false
}

func (m *CompileOptions) GetCppRelOut() string {
	if m != nil {
		return m.CppRelOut
	}
	return ""
}

func (m *CompileOptions) GetCsharp() bool {
	if m != nil {
		return m.Csharp
	}
	return false
}

func (m *CompileOptions) GetCsharpRelOut() string {
	if m != nil {
		return m.CsharpRelOut
	}
	return ""
}

func (m *CompileOptions) GetGo() bool {
	if m != nil {
		return m.Go
	}
	return false
}

func (m *CompileOptions) GetGoPluginType() GoPluginType {
	if m != nil {
		return m.GoPluginType
	}
	return GoPluginType_GO_PLUGIN_TYPE_NONE
}

func (m *CompileOptions) GetGoRelOut() string {
	if m != nil {
		return m.GoRelOut
	}
	return ""
}

func (m *CompileOptions) GetGoImportPath() string {
	if m != nil {
		return m.GoImportPath
	}
	return ""
}

func (m *CompileOptions) GetGoNoDefaultModifiers() bool {
	if m != nil {
		return m.GoNoDefaultModifiers
	}
	return false
}

func (m *CompileOptions) GetGoModifiers() map[string]string {
	if m != nil {
		return m.GoModifiers
	}
	return nil
}

func (m *CompileOptions) GetGogo() bool {
	if m != nil {
		return m.Gogo
	}
	return false
}

func (m *CompileOptions) GetGogoPluginType() GogoPluginType {
	if m != nil {
		return m.GogoPluginType
	}
	return GogoPluginType_GOGO_PLUGIN_TYPE_NONE
}

func (m *CompileOptions) GetGogoRelOut() string {
	if m != nil {
		return m.GogoRelOut
	}
	return ""
}

func (m *CompileOptions) GetGogoImportPath() string {
	if m != nil {
		return m.GogoImportPath
	}
	return ""
}

func (m *CompileOptions) GetGogoNoDefaultModifiers() bool {
	if m != nil {
		return m.GogoNoDefaultModifiers
	}
	return false
}

func (m *CompileOptions) GetGogoModifiers() map[string]string {
	if m != nil {
		return m.GogoModifiers
	}
	return nil
}

func (m *CompileOptions) GetObjc() bool {
	if m != nil {
		return m.Objc
	}
	return false
}

func (m *CompileOptions) GetObjcRelOut() string {
	if m != nil {
		return m.ObjcRelOut
	}
	return ""
}

func (m *CompileOptions) GetPython() bool {
	if m != nil {
		return m.Python
	}
	return false
}

func (m *CompileOptions) GetPythonRelOut() string {
	if m != nil {
		return m.PythonRelOut
	}
	return ""
}

func (m *CompileOptions) GetRuby() bool {
	if m != nil {
		return m.Ruby
	}
	return false
}

func (m *CompileOptions) GetRubyRelOut() string {
	if m != nil {
		return m.RubyRelOut
	}
	return ""
}

func (m *CompileOptions) GetDescriptorSet() bool {
	if m != nil {
		return m.DescriptorSet
	}
	return false
}

func (m *CompileOptions) GetDescriptorSetRelOut() string {
	if m != nil {
		return m.DescriptorSetRelOut
	}
	return ""
}

func (m *CompileOptions) GetDescriptorSetFileName() string {
	if m != nil {
		return m.DescriptorSetFileName
	}
	return ""
}

func (m *CompileOptions) GetDescriptorSetIncludeImports() bool {
	if m != nil {
		return m.DescriptorSetIncludeImports
	}
	return false
}

type Command struct {
	Arg []string `protobuf:"bytes,1,rep,name=arg,proto3" json:"arg,omitempty"`
}

func (m *Command) Reset()         { *m = Command{} }
func (m *Command) String() string { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()    {}
func (*Command) Descriptor() ([]byte, []int) {
	return fileDescriptor_protoc_6cb717615ecba7f8, []int{1}
}
func (m *Command) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Command) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Command.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Command) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command.Merge(dst, src)
}
func (m *Command) XXX_Size() int {
	return m.Size()
}
func (m *Command) XXX_DiscardUnknown() {
	xxx_messageInfo_Command.DiscardUnknown(m)
}

var xxx_messageInfo_Command proto.InternalMessageInfo

func (m *Command) GetArg() []string {
	if m != nil {
		return m.Arg
	}
	return nil
}

type CompileInfo struct {
	Command         []*Command      `protobuf:"bytes,1,rep,name=command,proto3" json:"command,omitempty"`
	InputSizeBytes  uint64          `protobuf:"varint,2,opt,name=input_size_bytes,json=inputSizeBytes,proto3" json:"input_size_bytes,omitempty"`
	OutputSizeBytes uint64          `protobuf:"varint,3,opt,name=output_size_bytes,json=outputSizeBytes,proto3" json:"output_size_bytes,omitempty"`
	Duration        *types.Duration `protobuf:"bytes,4,opt,name=duration,proto3" json:"duration,omitempty"`
}

func (m *CompileInfo) Reset()         { *m = CompileInfo{} }
func (m *CompileInfo) String() string { return proto.CompactTextString(m) }
func (*CompileInfo) ProtoMessage()    {}
func (*CompileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_protoc_6cb717615ecba7f8, []int{2}
}
func (m *CompileInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompileInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CompileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompileInfo.Merge(dst, src)
}
func (m *CompileInfo) XXX_Size() int {
	return m.Size()
}
func (m *CompileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CompileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CompileInfo proto.InternalMessageInfo

func (m *CompileInfo) GetCommand() []*Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *CompileInfo) GetInputSizeBytes() uint64 {
	if m != nil {
		return m.InputSizeBytes
	}
	return 0
}

func (m *CompileInfo) GetOutputSizeBytes() uint64 {
	if m != nil {
		return m.OutputSizeBytes
	}
	return 0
}

func (m *CompileInfo) GetDuration() *types.Duration {
	if m != nil {
		return m.Duration
	}
	return nil
}

type CompileRequest struct {
	Tar            []byte          `protobuf:"bytes,1,opt,name=tar,proto3" json:"tar,omitempty"`
	CompileOptions *CompileOptions `protobuf:"bytes,2,opt,name=compile_options,json=compileOptions,proto3" json:"compile_options,omitempty"`
}

func (m *CompileRequest) Reset()         { *m = CompileRequest{} }
func (m *CompileRequest) String() string { return proto.CompactTextString(m) }
func (*CompileRequest) ProtoMessage()    {}
func (*CompileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_protoc_6cb717615ecba7f8, []int{3}
}
func (m *CompileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CompileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompileRequest.Merge(dst, src)
}
func (m *CompileRequest) XXX_Size() int {
	return m.Size()
}
func (m *CompileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompileRequest proto.InternalMessageInfo

func (m *CompileRequest) GetTar() []byte {
	if m != nil {
		return m.Tar
	}
	return nil
}

func (m *CompileRequest) GetCompileOptions() *CompileOptions {
	if m != nil {
		return m.CompileOptions
	}
	return nil
}

type CompileResponse struct {
	Tar         []byte       `protobuf:"bytes,1,opt,name=tar,proto3" json:"tar,omitempty"`
	CompileInfo *CompileInfo `protobuf:"bytes,2,opt,name=compile_info,json=compileInfo,proto3" json:"compile_info,omitempty"`
}

func (m *CompileResponse) Reset()         { *m = CompileResponse{} }
func (m *CompileResponse) String() string { return proto.CompactTextString(m) }
func (*CompileResponse) ProtoMessage()    {}
func (*CompileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_protoc_6cb717615ecba7f8, []int{4}
}
func (m *CompileResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompileResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompileResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CompileResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompileResponse.Merge(dst, src)
}
func (m *CompileResponse) XXX_Size() int {
	return m.Size()
}
func (m *CompileResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CompileResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CompileResponse proto.InternalMessageInfo

func (m *CompileResponse) GetTar() []byte {
	if m != nil {
		return m.Tar
	}
	return nil
}

func (m *CompileResponse) GetCompileInfo() *CompileInfo {
	if m != nil {
		return m.CompileInfo
	}
	return nil
}

func init() {
	proto.RegisterType((*CompileOptions)(nil), "api.CompileOptions")
	proto.RegisterMapType((map[string]string)(nil), "api.CompileOptions.GoModifiersEntry")
	proto.RegisterMapType((map[string]string)(nil), "api.CompileOptions.GogoModifiersEntry")
	proto.RegisterType((*Command)(nil), "api.Command")
	proto.RegisterType((*CompileInfo)(nil), "api.CompileInfo")
	proto.RegisterType((*CompileRequest)(nil), "api.CompileRequest")
	proto.RegisterType((*CompileResponse)(nil), "api.CompileResponse")
	proto.RegisterEnum("api.GoPluginType", GoPluginType_name, GoPluginType_value)
	proto.RegisterEnum("api.GogoPluginType", GogoPluginType_name, GogoPluginType_value)
}
func (m *CompileOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompileOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Grpc {
		dAtA[i] = 0x8
		i++
		if m.Grpc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GrpcGateway {
		dAtA[i] = 0x10
		i++
		if m.GrpcGateway {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NoDefaultIncludes {
		dAtA[i] = 0x18
		i++
		if m.NoDefaultIncludes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ExcludePattern) > 0 {
		for _, s := range m.ExcludePattern {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RelContext) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(len(m.RelContext)))
		i += copy(dAtA[i:], m.RelContext)
	}
	if len(m.ExtraPluginFlag) > 0 {
		for _, s := range m.ExtraPluginFlag {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Cpp {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.Cpp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CppRelOut) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(len(m.CppRelOut)))
		i += copy(dAtA[i:], m.CppRelOut)
	}
	if m.Csharp {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		if m.Csharp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CsharpRelOut) > 0 {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(len(m.CsharpRelOut)))
		i += copy(dAtA[i:], m.CsharpRelOut)
	}
	if m.Go {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		if m.Go {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GoPluginType != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(m.GoPluginType))
	}
	if len(m.GoRelOut) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(len(m.GoRelOut)))
		i += copy(dAtA[i:], m.GoRelOut)
	}
	if len(m.GoImportPath) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(len(m.GoImportPath)))
		i += copy(dAtA[i:], m.GoImportPath)
	}
	if m.GoNoDefaultModifiers {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		if m.GoNoDefaultModifiers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.GoModifiers) > 0 {
		for k, _ := range m.GoModifiers {
			dAtA[i] = 0xea
			i++
			dAtA[i] = 0x2
			i++
			v := m.GoModifiers[k]
			mapSize := 1 + len(k) + sovProtoc(uint64(len(k))) + 1 + len(v) + sovProtoc(uint64(len(v)))
			i = encodeVarintProtoc(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintProtoc(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintProtoc(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Gogo {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x3
		i++
		if m.Gogo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GogoPluginType != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(m.GogoPluginType))
	}
	if len(m.GogoRelOut) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(len(m.GogoRelOut)))
		i += copy(dAtA[i:], m.GogoRelOut)
	}
	if len(m.GogoImportPath) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(len(m.GogoImportPath)))
		i += copy(dAtA[i:], m.GogoImportPath)
	}
	if m.GogoNoDefaultModifiers {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x3
		i++
		if m.GogoNoDefaultModifiers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.GogoModifiers) > 0 {
		for k, _ := range m.GogoModifiers {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x3
			i++
			v := m.GogoModifiers[k]
			mapSize := 1 + len(k) + sovProtoc(uint64(len(k))) + 1 + len(v) + sovProtoc(uint64(len(v)))
			i = encodeVarintProtoc(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintProtoc(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintProtoc(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Objc {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x3
		i++
		if m.Objc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ObjcRelOut) > 0 {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(len(m.ObjcRelOut)))
		i += copy(dAtA[i:], m.ObjcRelOut)
	}
	if m.Python {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x4
		i++
		if m.Python {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PythonRelOut) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(len(m.PythonRelOut)))
		i += copy(dAtA[i:], m.PythonRelOut)
	}
	if m.Ruby {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x5
		i++
		if m.Ruby {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.RubyRelOut) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(len(m.RubyRelOut)))
		i += copy(dAtA[i:], m.RubyRelOut)
	}
	if m.DescriptorSet {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x5
		i++
		if m.DescriptorSet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.DescriptorSetRelOut) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(len(m.DescriptorSetRelOut)))
		i += copy(dAtA[i:], m.DescriptorSetRelOut)
	}
	if len(m.DescriptorSetFileName) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(len(m.DescriptorSetFileName)))
		i += copy(dAtA[i:], m.DescriptorSetFileName)
	}
	if m.DescriptorSetIncludeImports {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x5
		i++
		if m.DescriptorSetIncludeImports {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Command) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Command) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Arg) > 0 {
		for _, s := range m.Arg {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CompileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompileInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		for _, msg := range m.Command {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProtoc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.InputSizeBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(m.InputSizeBytes))
	}
	if m.OutputSizeBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(m.OutputSizeBytes))
	}
	if m.Duration != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(m.Duration.Size()))
		n1, err := m.Duration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *CompileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tar) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(len(m.Tar)))
		i += copy(dAtA[i:], m.Tar)
	}
	if m.CompileOptions != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(m.CompileOptions.Size()))
		n2, err := m.CompileOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *CompileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompileResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tar) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(len(m.Tar)))
		i += copy(dAtA[i:], m.Tar)
	}
	if m.CompileInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtoc(dAtA, i, uint64(m.CompileInfo.Size()))
		n3, err := m.CompileInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func encodeVarintProtoc(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CompileOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Grpc {
		n += 2
	}
	if m.GrpcGateway {
		n += 2
	}
	if m.NoDefaultIncludes {
		n += 2
	}
	if len(m.ExcludePattern) > 0 {
		for _, s := range m.ExcludePattern {
			l = len(s)
			n += 1 + l + sovProtoc(uint64(l))
		}
	}
	l = len(m.RelContext)
	if l > 0 {
		n += 1 + l + sovProtoc(uint64(l))
	}
	if len(m.ExtraPluginFlag) > 0 {
		for _, s := range m.ExtraPluginFlag {
			l = len(s)
			n += 1 + l + sovProtoc(uint64(l))
		}
	}
	if m.Cpp {
		n += 3
	}
	l = len(m.CppRelOut)
	if l > 0 {
		n += 2 + l + sovProtoc(uint64(l))
	}
	if m.Csharp {
		n += 3
	}
	l = len(m.CsharpRelOut)
	if l > 0 {
		n += 2 + l + sovProtoc(uint64(l))
	}
	if m.Go {
		n += 3
	}
	if m.GoPluginType != 0 {
		n += 2 + sovProtoc(uint64(m.GoPluginType))
	}
	l = len(m.GoRelOut)
	if l > 0 {
		n += 2 + l + sovProtoc(uint64(l))
	}
	l = len(m.GoImportPath)
	if l > 0 {
		n += 2 + l + sovProtoc(uint64(l))
	}
	if m.GoNoDefaultModifiers {
		n += 3
	}
	if len(m.GoModifiers) > 0 {
		for k, v := range m.GoModifiers {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovProtoc(uint64(len(k))) + 1 + len(v) + sovProtoc(uint64(len(v)))
			n += mapEntrySize + 2 + sovProtoc(uint64(mapEntrySize))
		}
	}
	if m.Gogo {
		n += 3
	}
	if m.GogoPluginType != 0 {
		n += 2 + sovProtoc(uint64(m.GogoPluginType))
	}
	l = len(m.GogoRelOut)
	if l > 0 {
		n += 2 + l + sovProtoc(uint64(l))
	}
	l = len(m.GogoImportPath)
	if l > 0 {
		n += 2 + l + sovProtoc(uint64(l))
	}
	if m.GogoNoDefaultModifiers {
		n += 3
	}
	if len(m.GogoModifiers) > 0 {
		for k, v := range m.GogoModifiers {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovProtoc(uint64(len(k))) + 1 + len(v) + sovProtoc(uint64(len(v)))
			n += mapEntrySize + 2 + sovProtoc(uint64(mapEntrySize))
		}
	}
	if m.Objc {
		n += 3
	}
	l = len(m.ObjcRelOut)
	if l > 0 {
		n += 2 + l + sovProtoc(uint64(l))
	}
	if m.Python {
		n += 3
	}
	l = len(m.PythonRelOut)
	if l > 0 {
		n += 2 + l + sovProtoc(uint64(l))
	}
	if m.Ruby {
		n += 3
	}
	l = len(m.RubyRelOut)
	if l > 0 {
		n += 2 + l + sovProtoc(uint64(l))
	}
	if m.DescriptorSet {
		n += 3
	}
	l = len(m.DescriptorSetRelOut)
	if l > 0 {
		n += 2 + l + sovProtoc(uint64(l))
	}
	l = len(m.DescriptorSetFileName)
	if l > 0 {
		n += 2 + l + sovProtoc(uint64(l))
	}
	if m.DescriptorSetIncludeImports {
		n += 3
	}
	return n
}

func (m *Command) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Arg) > 0 {
		for _, s := range m.Arg {
			l = len(s)
			n += 1 + l + sovProtoc(uint64(l))
		}
	}
	return n
}

func (m *CompileInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Command) > 0 {
		for _, e := range m.Command {
			l = e.Size()
			n += 1 + l + sovProtoc(uint64(l))
		}
	}
	if m.InputSizeBytes != 0 {
		n += 1 + sovProtoc(uint64(m.InputSizeBytes))
	}
	if m.OutputSizeBytes != 0 {
		n += 1 + sovProtoc(uint64(m.OutputSizeBytes))
	}
	if m.Duration != nil {
		l = m.Duration.Size()
		n += 1 + l + sovProtoc(uint64(l))
	}
	return n
}

func (m *CompileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tar)
	if l > 0 {
		n += 1 + l + sovProtoc(uint64(l))
	}
	if m.CompileOptions != nil {
		l = m.CompileOptions.Size()
		n += 1 + l + sovProtoc(uint64(l))
	}
	return n
}

func (m *CompileResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tar)
	if l > 0 {
		n += 1 + l + sovProtoc(uint64(l))
	}
	if m.CompileInfo != nil {
		l = m.CompileInfo.Size()
		n += 1 + l + sovProtoc(uint64(l))
	}
	return n
}

func sovProtoc(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozProtoc(x uint64) (n int) {
	return sovProtoc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CompileOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompileOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompileOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grpc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Grpc = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcGateway", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GrpcGateway = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDefaultIncludes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoDefaultIncludes = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludePattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludePattern = append(m.ExcludePattern, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelContext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelContext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraPluginFlag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraPluginFlag = append(m.ExtraPluginFlag, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cpp = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CppRelOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CppRelOut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Csharp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Csharp = bool(v != 0)
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CsharpRelOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CsharpRelOut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Go", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Go = bool(v != 0)
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoPluginType", wireType)
			}
			m.GoPluginType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoPluginType |= (GoPluginType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoRelOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoRelOut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoImportPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoImportPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoNoDefaultModifiers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GoNoDefaultModifiers = bool(v != 0)
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoModifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GoModifiers == nil {
				m.GoModifiers = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProtoc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProtoc
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProtoc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthProtoc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GoModifiers[mapkey] = mapvalue
			iNdEx = postIndex
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gogo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gogo = bool(v != 0)
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GogoPluginType", wireType)
			}
			m.GogoPluginType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GogoPluginType |= (GogoPluginType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GogoRelOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GogoRelOut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GogoImportPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GogoImportPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GogoNoDefaultModifiers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GogoNoDefaultModifiers = bool(v != 0)
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GogoModifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GogoModifiers == nil {
				m.GogoModifiers = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProtoc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProtoc
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProtoc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthProtoc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GogoModifiers[mapkey] = mapvalue
			iNdEx = postIndex
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Objc = bool(v != 0)
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjcRelOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjcRelOut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 70:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Python", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Python = bool(v != 0)
		case 71:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PythonRelOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PythonRelOut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ruby", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ruby = bool(v != 0)
		case 81:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RubyRelOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RubyRelOut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 90:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DescriptorSet = bool(v != 0)
		case 91:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorSetRelOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescriptorSetRelOut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 92:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorSetFileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescriptorSetFileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 93:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorSetIncludeImports", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DescriptorSetIncludeImports = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Command) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arg = append(m.Arg, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, &Command{})
			if err := m.Command[len(m.Command)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSizeBytes", wireType)
			}
			m.InputSizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputSizeBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSizeBytes", wireType)
			}
			m.OutputSizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputSizeBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Duration == nil {
				m.Duration = &types.Duration{}
			}
			if err := m.Duration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tar", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tar = append(m.Tar[:0], dAtA[iNdEx:postIndex]...)
			if m.Tar == nil {
				m.Tar = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompileOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompileOptions == nil {
				m.CompileOptions = &CompileOptions{}
			}
			if err := m.CompileOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tar", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tar = append(m.Tar[:0], dAtA[iNdEx:postIndex]...)
			if m.Tar == nil {
				m.Tar = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompileInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompileInfo == nil {
				m.CompileInfo = &CompileInfo{}
			}
			if err := m.CompileInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProtoc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtoc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtoc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthProtoc
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProtoc
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProtoc(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProtoc = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtoc   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("api/protoc.proto", fileDescriptor_protoc_6cb717615ecba7f8) }

var fileDescriptor_protoc_6cb717615ecba7f8 = []byte{
	// 1067 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0x5d, 0x73, 0xdb, 0x44,
	0x17, 0x8e, 0x62, 0xf7, 0x23, 0x47, 0xae, 0xa2, 0x6c, 0x3e, 0xba, 0x49, 0xde, 0x57, 0x31, 0x9e,
	0x50, 0x4c, 0x00, 0x77, 0xc6, 0x21, 0x0d, 0x30, 0x0d, 0x43, 0x9b, 0x26, 0x1e, 0x0f, 0x6d, 0x62,
	0x94, 0x30, 0x43, 0xf9, 0x18, 0x21, 0xcb, 0xeb, 0x8d, 0x40, 0xd6, 0x2e, 0xd2, 0x0a, 0xe2, 0xfe,
	0x0a, 0x6e, 0xf9, 0x03, 0xfc, 0x10, 0xae, 0xb8, 0xec, 0x25, 0x97, 0x4c, 0xf2, 0x47, 0x98, 0xdd,
	0x95, 0x1d, 0xcb, 0x35, 0x17, 0x5c, 0xe9, 0xec, 0x73, 0x9e, 0xf3, 0xa1, 0x67, 0x8f, 0x8e, 0xc0,
	0xf6, 0x79, 0xf8, 0x90, 0x27, 0x4c, 0xb0, 0xa0, 0xa1, 0x1e, 0xa8, 0xe4, 0xf3, 0x70, 0xc3, 0xa1,
	0x8c, 0xd1, 0x88, 0x68, 0x4f, 0x37, 0xeb, 0x3f, 0xec, 0x65, 0x89, 0x2f, 0x42, 0x16, 0x6b, 0x52,
	0xed, 0x37, 0x13, 0xac, 0x43, 0x36, 0xe0, 0x61, 0x44, 0x4e, 0xb9, 0xc4, 0x53, 0x84, 0xa0, 0x4c,
	0x13, 0x1e, 0x60, 0xa3, 0x6a, 0xd4, 0xef, 0xba, 0xca, 0x46, 0x6f, 0x41, 0x45, 0x3e, 0x3d, 0xea,
	0x0b, 0xf2, 0x8b, 0x3f, 0xc4, 0xf3, 0xca, 0x67, 0x4a, 0xac, 0xa5, 0x21, 0xd4, 0x80, 0xe5, 0x98,
	0x79, 0x3d, 0xd2, 0xf7, 0xb3, 0x48, 0x78, 0x61, 0x1c, 0x44, 0x59, 0x8f, 0xa4, 0xb8, 0xa4, 0x98,
	0x4b, 0x31, 0x7b, 0xa6, 0x3d, 0xed, 0xdc, 0x81, 0xde, 0x81, 0x45, 0x72, 0xa9, 0x6c, 0x8f, 0xfb,
	0x42, 0x90, 0x24, 0xc6, 0xe5, 0x6a, 0xa9, 0xbe, 0xe0, 0x5a, 0x39, 0xdc, 0xd1, 0x28, 0xda, 0x02,
	0x33, 0x21, 0x91, 0x17, 0xb0, 0x58, 0x90, 0x4b, 0x81, 0x6f, 0x55, 0x8d, 0xfa, 0x82, 0x0b, 0x09,
	0x89, 0x0e, 0x35, 0x82, 0x76, 0x60, 0x89, 0x5c, 0x8a, 0xc4, 0xf7, 0x78, 0x94, 0xd1, 0x30, 0xf6,
	0xfa, 0x91, 0x4f, 0xf1, 0x6d, 0x95, 0x6b, 0x51, 0x39, 0x3a, 0x0a, 0x3f, 0x8e, 0x7c, 0x8a, 0x6c,
	0x28, 0x05, 0x9c, 0xe3, 0x15, 0xd5, 0x95, 0x34, 0x91, 0x03, 0x66, 0xc0, 0xb9, 0x27, 0x4b, 0xb0,
	0x4c, 0xe0, 0x55, 0x95, 0x7e, 0x21, 0xe0, 0xdc, 0x25, 0xd1, 0x69, 0x26, 0xd0, 0x1a, 0xdc, 0x0e,
	0xd2, 0x0b, 0x3f, 0xe1, 0xd8, 0x51, 0x41, 0xf9, 0x09, 0x6d, 0x83, 0xa5, 0xad, 0x71, 0xe8, 0x96,
	0x0a, 0xad, 0x68, 0x34, 0x8f, 0xb6, 0x60, 0x9e, 0x32, 0x5c, 0x57, 0x91, 0xf3, 0x94, 0xa1, 0x7d,
	0xb0, 0x28, 0x1b, 0x35, 0x2a, 0x86, 0x9c, 0xe0, 0x77, 0xab, 0x46, 0xdd, 0x6a, 0x2e, 0x35, 0x7c,
	0x1e, 0x36, 0x5a, 0x4c, 0xb7, 0x7a, 0x3e, 0xe4, 0xc4, 0xad, 0xd0, 0x89, 0x13, 0xfa, 0x1f, 0x00,
	0x65, 0xe3, 0x52, 0x3b, 0xaa, 0xd4, 0x5d, 0xca, 0xf2, 0x32, 0xdb, 0x2a, 0x6d, 0x38, 0xe0, 0x2c,
	0x11, 0x52, 0xce, 0x0b, 0xfc, 0x9e, 0x6e, 0x86, 0xb2, 0xb6, 0x02, 0x3b, 0xbe, 0xb8, 0x40, 0x7b,
	0x70, 0x9f, 0x32, 0x6f, 0xe2, 0x96, 0x06, 0xac, 0x17, 0xf6, 0x43, 0x92, 0xa4, 0xf8, 0x7d, 0xd5,
	0xe1, 0x0a, 0x65, 0x27, 0xa3, 0x8b, 0x7a, 0x31, 0xf2, 0xa1, 0x16, 0x54, 0x28, 0x9b, 0xe0, 0x7e,
	0x50, 0x2d, 0xd5, 0xcd, 0xe6, 0xb6, 0xea, 0xb8, 0x38, 0x3b, 0x8d, 0x16, 0x1b, 0x87, 0x1d, 0xc5,
	0x22, 0x19, 0xba, 0x26, 0xbd, 0x41, 0xd4, 0x64, 0x31, 0xca, 0x70, 0x33, 0x9f, 0x2c, 0x46, 0x19,
	0x3a, 0x00, 0x5b, 0x3e, 0x0b, 0x92, 0xec, 0x2a, 0x49, 0x96, 0x73, 0x49, 0x26, 0x65, 0x70, 0x2d,
	0x5a, 0x38, 0xa3, 0xaa, 0xec, 0x6d, 0x42, 0x98, 0x0f, 0xf5, 0x74, 0x48, 0x2c, 0x97, 0xa6, 0x9e,
	0x17, 0x98, 0x14, 0x67, 0x4f, 0xb1, 0x54, 0xae, 0x09, 0x79, 0x3e, 0x86, 0x75, 0xc5, 0x9c, 0x29,
	0xd0, 0x23, 0xd5, 0xf3, 0x9a, 0x24, 0xcc, 0x90, 0xe8, 0x05, 0xa8, 0x64, 0x13, 0xfc, 0x7d, 0x25,
	0xd2, 0x83, 0xd9, 0x22, 0xd1, 0x69, 0x99, 0xee, 0x51, 0x36, 0x25, 0x14, 0xeb, 0xfe, 0x10, 0xe0,
	0xc7, 0x5a, 0x28, 0x69, 0xcb, 0x37, 0x95, 0xcf, 0xf1, 0x9b, 0x1e, 0xe8, 0x37, 0x95, 0xd8, 0xcd,
	0xa4, 0xf2, 0xa1, 0xb8, 0x60, 0x31, 0x3e, 0xd6, 0x93, 0xaa, 0x4f, 0x72, 0x38, 0xb4, 0x35, 0x8e,
	0x6d, 0xe9, 0xe1, 0xd0, 0x68, 0x1e, 0x8d, 0xa0, 0x9c, 0x64, 0xdd, 0x21, 0xee, 0xe8, 0x9a, 0xd2,
	0x96, 0x35, 0xe5, 0x73, 0x1c, 0xf7, 0x45, 0xfe, 0xed, 0x65, 0xdd, 0x61, 0x1e, 0xf5, 0x36, 0x58,
	0x3d, 0x92, 0x06, 0x49, 0xc8, 0x05, 0x4b, 0xbc, 0x94, 0x08, 0xfc, 0xb5, 0x8a, 0xbf, 0x77, 0x83,
	0x9e, 0x11, 0x81, 0x76, 0x61, 0xad, 0x48, 0x1b, 0xa7, 0xfc, 0x46, 0xa5, 0x5c, 0x2e, 0xd0, 0xf3,
	0xdc, 0xfb, 0x80, 0xa7, 0x82, 0xfa, 0x61, 0x44, 0xbc, 0xd8, 0x1f, 0x10, 0xfc, 0xad, 0x0a, 0x5b,
	0x2d, 0x84, 0x1d, 0x87, 0x11, 0x39, 0xf1, 0x07, 0x04, 0x1d, 0x82, 0x33, 0x15, 0x98, 0xaf, 0xa3,
	0x7c, 0x08, 0x52, 0xfc, 0x9d, 0x6a, 0x72, 0xb3, 0x10, 0x9e, 0x6f, 0x26, 0x3d, 0x10, 0xe9, 0xc6,
	0xa7, 0x60, 0x4f, 0x4f, 0xb3, 0xdc, 0x1e, 0x3f, 0x92, 0xa1, 0xda, 0x8c, 0x0b, 0xae, 0x34, 0xd1,
	0x0a, 0xdc, 0xfa, 0xd9, 0x8f, 0x32, 0xa2, 0x36, 0xe2, 0x82, 0xab, 0x0f, 0x9f, 0xcc, 0x7f, 0x64,
	0x6c, 0x7c, 0x06, 0xe8, 0xcd, 0x8b, 0xfe, 0x2f, 0x19, 0x6a, 0x9b, 0x70, 0xe7, 0x90, 0x0d, 0x06,
	0x7e, 0xdc, 0x93, 0x61, 0x7e, 0x42, 0xb1, 0xa1, 0x96, 0x9a, 0x34, 0x6b, 0x7f, 0x18, 0x60, 0xe6,
	0x73, 0xd5, 0x8e, 0xfb, 0x0c, 0x3d, 0x80, 0x3b, 0x81, 0x26, 0x2b, 0x96, 0xd9, 0xac, 0x8c, 0x46,
	0x4f, 0x62, 0xee, 0xc8, 0x29, 0x3f, 0x87, 0x30, 0xe6, 0x99, 0xf0, 0xd2, 0xf0, 0x15, 0xf1, 0xba,
	0x43, 0x41, 0x52, 0x55, 0xb9, 0xec, 0x5a, 0x0a, 0x3f, 0x0b, 0x5f, 0x91, 0xa7, 0x12, 0x95, 0x6b,
	0x95, 0x65, 0x62, 0x8a, 0x5a, 0x52, 0xd4, 0x45, 0xed, 0xb8, 0xe1, 0xee, 0xc1, 0xdd, 0xd1, 0x8f,
	0x05, 0x97, 0xab, 0x46, 0xdd, 0x6c, 0xae, 0x37, 0xf4, 0x9f, 0xa7, 0x31, 0xfa, 0xf3, 0x34, 0x9e,
	0xe5, 0x04, 0x77, 0x4c, 0xad, 0x7d, 0x3f, 0xfe, 0xf9, 0xb8, 0xe4, 0xa7, 0x8c, 0xa4, 0x42, 0xbe,
	0xa8, 0xf0, 0x13, 0xa5, 0x4f, 0xc5, 0x95, 0x26, 0x7a, 0x0c, 0x8b, 0x81, 0xe6, 0x78, 0x4c, 0x7f,
	0x40, 0xaa, 0x5f, 0x33, 0xdf, 0x0f, 0xc5, 0x6f, 0xcb, 0xb5, 0x82, 0xc2, 0xb9, 0xf6, 0x15, 0x2c,
	0x8e, 0x2b, 0xa4, 0x9c, 0xc5, 0x29, 0x99, 0x51, 0x62, 0x17, 0x2a, 0xa3, 0x12, 0x61, 0xdc, 0x67,
	0x79, 0x7e, 0x7b, 0x32, 0xbf, 0xd4, 0xd8, 0x35, 0x83, 0x9b, 0xc3, 0xce, 0x4b, 0xa8, 0x4c, 0xae,
	0x6b, 0x74, 0x1f, 0x96, 0x5b, 0xa7, 0x5e, 0xe7, 0xf9, 0x97, 0xad, 0xf6, 0x89, 0x77, 0xfe, 0xb2,
	0x73, 0xe4, 0x9d, 0x9c, 0x9e, 0x1c, 0xd9, 0x73, 0x68, 0x15, 0x96, 0xa6, 0x1c, 0xad, 0x53, 0xdb,
	0x40, 0xeb, 0xb0, 0xfa, 0x06, 0x7c, 0xfc, 0xe4, 0xec, 0xdc, 0x9e, 0xdf, 0xf9, 0xdd, 0x00, 0xab,
	0xb8, 0xf7, 0x34, 0x7b, 0x76, 0xfe, 0x59, 0x2e, 0x09, 0xd8, 0x06, 0xfa, 0x3f, 0xac, 0xcf, 0x74,
	0xe9, 0x3a, 0x68, 0x0b, 0x36, 0xff, 0xd5, 0x7d, 0xe4, 0xda, 0x25, 0xe4, 0xc0, 0xc6, 0x4c, 0xc2,
	0xd9, 0xf3, 0xf6, 0xe1, 0xe7, 0x76, 0xb9, 0x79, 0x00, 0xa5, 0x27, 0x9d, 0x36, 0x7a, 0xa4, 0x06,
	0x55, 0x2a, 0x83, 0x0a, 0x97, 0x92, 0x5f, 0xea, 0xc6, 0x4a, 0x11, 0xd4, 0xf7, 0x50, 0x9b, 0x7b,
	0x8a, 0xff, 0xbc, 0x72, 0x8c, 0xd7, 0x57, 0x8e, 0xf1, 0xf7, 0x95, 0x63, 0xfc, 0x7a, 0xed, 0xcc,
	0xbd, 0xbe, 0x76, 0xe6, 0xfe, 0xba, 0x76, 0xe6, 0xba, 0xb7, 0xd5, 0xd4, 0xec, 0xfe, 0x13, 0x00,
	0x00, 0xff, 0xff, 0x8d, 0xe9, 0xd0, 0x0a, 0xd6, 0x08, 0x00, 0x00,
}
